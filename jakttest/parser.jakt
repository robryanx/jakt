//
// Copyright (c) 2022, Jes√∫s Lapastora <cyber.gsuscode@gmail.com>
//
// SPDX-License-Identifier: BSD-2-Clause
import error { JaktError }
import utility { panic, todo, Span }

enum ParsedTest {
    SuccessTest(output_filename: String?, output: String?, cppincludes: String)
    CompileErrorTest(output_filename: String?, output: String?, cppincludes: String)
    RuntimeErrorTest(output_filename: String?, output: String?, cppincludes: String)
    SkipTest
    ResultFile
    NoExpectOrSkip
}

function is_whitespace(anon byte: u8) -> bool => byte == b' ' or byte == b'\t' or byte == b'\r'

struct Parser {
    index: usize
    input: [u8]

    function is_eof(this) => .input.size() == .index

    function current(this) => .input[.index]

    function lex_literal(mut this, anon literal: String) -> bool {
        if .index + literal.length() >= .input.size() {
            return false
        }

        let start = .index

        for i in 0..literal.length() {
            if .current() != literal.byte_at(i) {
                .index = start
                return false
            }
            .index++
        }
        return true
    }

    function skip_whitespace(mut this) {
        while not .is_eof() and is_whitespace(.current()) {
            .index++
        }
    }

    function lex_string(mut this) -> Span? {
        if .is_eof() {
            return None
        }
        let start = .index
        while not .is_eof() and .current() != b'\n' {
            .index++
            if .current() == b'\\' and not .is_eof() {
                .index++
            }
        }

        if start == .index {
            return None
        }

        .index++
        return Span(start, end: .index - 1)
    }

    function lex_quoted_string(mut this) -> Span? {
        if .is_eof() or .current() != b'"' {
            return None
        }
        .index++
        let start = .index
        while not .is_eof() and .current() != b'"' {
            let current = .current()
            .index++
            if current == b'\\' and not .is_eof() {
                .index++
            }
        }

        if .current() != b'"' {
            return None
        }
        .index++
        return Span(start, end: .index - 1)
    }

    function get_result(mut this) throws -> [u8] {
        .parse_test()

        while .current() == b'\n' {
            .index++
        }

        return .input[.index..].to_array()
    }

    function parse_test(mut this) throws -> ParsedTest {
        if not .lex_literal("///") {
            .index++
            return ParsedTest::NoExpectOrSkip
        }
        .skip_whitespace()
        if not .lex_literal("Expect:") {
            return ParsedTest::NoExpectOrSkip
        }

        .skip_whitespace()

        if .lex_literal("Skip") {
            return ParsedTest::SkipTest
        }

        if .lex_literal("Result") {
            return ParsedTest::ResultFile
        }

        if .is_eof() or .current() != b'\n' {
            return ParsedTest::NoExpectOrSkip
        }
        .index++
        return .parse_test_information()
    }

    function parse_test_information(mut this) throws -> ParsedTest {
        mut success_test = false
        mut runtime_error = false
        mut compile_error = false
        mut has_cppincludes = false
        mut output_filename: String? = None
        mut output: String? = None
        mut cppincludes = ""

        while not .is_eof() {
            if not .lex_literal("///") {
                break
            }
            .skip_whitespace()
            guard .current() == b'-' and not .is_eof() else {
                break
            }
            .index++
            .skip_whitespace()

            mut includes_line = false
            mut output_line = false

            if .lex_literal("cppincludes") {
                has_cppincludes = true

                includes_line = true
            } else if .lex_literal("output") {
                success_test = true

                output_line = true
            } else if .lex_literal("error") {
                compile_error = true

                output_line = true
            } else if .lex_literal("stderr") {
                runtime_error = true

                output_line = true
            }

            if (success_test as! u8 + compile_error as! u8 + runtime_error as! u8) > 1 {
                eprintln("Too many test directives")
                return ParsedTest::NoExpectOrSkip
            }

            guard success_test or compile_error or runtime_error or has_cppincludes else {
                return ParsedTest::NoExpectOrSkip
            }

            .skip_whitespace()
            if .is_eof() or .current() != b':' {
                continue
            }
            .index++
            .skip_whitespace()

            mut is_file_output = false
            mut string_span = .lex_quoted_string()
            if not string_span.has_value() {
                string_span = .lex_string()
                if not string_span.has_value() {
                    return ParsedTest::NoExpectOrSkip
                } else {
                    is_file_output = true
                }
            }

            // create the string
            let span = string_span!
            mut builder = StringBuilder::create()
            for i in span.start..span.end {
                builder.append(.input[i])
            }

            let parsed_string = parse_quoted_string(builder.to_string())

            .skip_whitespace()
            .index++

            if output_line {
                if is_file_output {
                    if not output_filename.has_value() {
                        output_filename = parsed_string
                    }
                } else {
                    if not output.has_value() {
                        output = parsed_string
                    }
                }
            } else if includes_line {
                cppincludes = parsed_string
            } else {
                panic("Unexpected token state in parse_test_information")
            }
        }

        if success_test {
            return ParsedTest::SuccessTest(output_filename, output, cppincludes)
        }
        if compile_error {
            return ParsedTest::CompileErrorTest(output_filename, output, cppincludes)
        }
        if runtime_error {
            return ParsedTest::RuntimeErrorTest(output_filename, output, cppincludes)
        }

        return ParsedTest::NoExpectOrSkip
    }

    function parse(input: [u8]) throws -> ParsedTest {
        mut parser = Parser(index: 0, input)
        return parser.parse_test()
    }

    function get_result(input: [u8]) throws -> [u8] {
        mut parser = Parser(index: 0, input)
        return parser.get_result()
    }
}

function parse_quoted_string(anon quote: String) throws -> String {
    mut builder = StringBuilder::create()
    mut i = 0uz
    while i < quote.length() {
        let ch = quote.byte_at(i)
        if ch == b'\\' and i + 1 < quote.length() {
            i += 1
            let ch = quote.byte_at(i)
            let escape = match ch {
                b'"' => "\""
                b'\\' => "\\"
                b'a' => "\0x07"
                b'b' => "\x08"
                b'f' => "\x0c"
                b'n' => "\n"
                b'r' => "\r"
                b't' => "\t"
                b'v' => "\x0b"
                else => {
                    panic(format("Unknown escape character: '{}'", ch))
                }
            }
            builder.append_string(escape)
        } else {
            builder.append(ch)
        }
        i += 1
    }
    return builder.to_string()
}
